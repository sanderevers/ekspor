<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  margin: auto;
  position: relative;
}

form {
  position: absolute;
  right: 10px;
  top: 10px;
}

.node {
  border: solid 1px white;
  font: 14px sans-serif;
  line-height: 12px;
  overflow: hidden;
  position: absolute;
  text-indent: 2px;
}

text {
    alignment-baseline : text-before-edge;
//    stroke : black ;
}

</style>
<body>
    <h2></h2>
    <svg class="exporting"></svg>&nbsp;&nbsp;&nbsp;<svg class="importing"></svg>
    <p>
    #imports: <span class="size"></span>
</p>
    <ul>
    </ul>

<script src="d3.min.js"></script>
<script>

var margin = {top: 40, right: 10, bottom: 10, left: 10},
    width = 800 - margin.left - margin.right,
    height = 800 - margin.top - margin.bottom;

var color = d3.scale.category20c();

var treemap = d3.layout.partition()
    .size([height,width])
    .value(function(d) { return d.size; });

var treemap2 = d3.layout.partition()
    .size([height,width])
    .value(function(d) { return d.size; });

var svge = d3.selectAll("svg.exporting")
    .style("position", "relative")
    .attr("width", (width + margin.left + margin.right) + "px")
    .attr("height", (height + margin.top + margin.bottom) + "px")
    .append("g")
        .attr("transform", "translate("+margin.left+","+ margin.top + ")");

var svgi = d3.selectAll("svg.importing")
    .style("position", "relative")
    .attr("width", (width + margin.left + margin.right) + "px")
    .attr("height", (height + margin.top + margin.bottom) + "px")
    .append("g")
        .attr("transform", "translate("+margin.left+","+ margin.top + ")");

load("");

function load(path) {
    console.log(path);
    d3.json(path_to_url(path), function(error, root) {
        d3.selectAll("h2 *").remove();
        p = d3.select("h2");
        var pathparts = path.split(".");
        for (var i=0; i<pathparts.length; i++) {
            if (pathparts[i][0]==="<") {
                p.append("text").text(" "+pathparts[i])
            } else {
                if (i>0) p.append("text").text(".");
                p.append("a")
                    .on("click",function(j) {return function() {load(pathparts.slice(0,j+1).join("."));}} (i))
                    .attr("href","#")
                    //.attr("href",path_to_url(pathparts.slice(0,i+1).join(".")))
                    .text(pathparts[i]);
            }
        }
        p.append("text").text(" (");
        p.append("a").text("html").attr("href",path_to_url_html(path));
        p.append("text").text(" | ");
        p.append("a").text("json").attr("href",path_to_url_json(path));
        p.append("text").text(")");


        var data_exporting = treemap.nodes(root);
        var data_importing = treemap2.nodes(root.exports_tree);
        var enode = svge.selectAll(".node")
            .data(data_exporting, function(d) {return "E-"+d.path;});
        var inode = svgi.selectAll(".importing .node")
            .data(data_importing, function(d) {return "I-"+d.path;});

        enode.transition()
            .duration(750)
            .call(position);

        var en = enode.enter().append("svg");
        en
            .on("click",function(d) {
                  load(d.path);
                })
            .on("mouseover",function(d) {d3.select(".size").text(d.value);})
            .attr("class", "node")
            .attr("x",width)
            .attr("y",0)
            .attr("height",0)
            .attr("width",0)
            .append("rect")
                .attr("height","100%")
                .attr("width","100%")
                .attr("fill",function(d) { return color(d.path); });
        en.append("text");
        en.transition().duration(750).call(position);

        enode
            .select("text")
                .text(function(d) { return d.name; });

        enode.exit().remove();

        inode.transition()
            .duration(750)
            .call(position);

        var n = inode.enter().append("svg");
        n
            .on("click",function(d) {
                  load(d.path);
                })
            .on("mouseover",function(d) {d3.select(".size").text(d.value);})
            .attr("class", "node")
            .attr("x",width)
            .attr("y",0)
            .attr("height",0)
            .attr("width",0)
            .append("rect")
                .attr("height","100%")
                .attr("width","100%")
                .attr("fill",function(d) { return color(d.path); });
        n.append("text");
        n.transition().duration(750).call(position);

        inode
            .select("text")
                .text(function(d) { return d.name; });

        inode.exit().remove();
    
    });
}

function position_div() {
  this.style("left", function(d) { return d.y + "px"; })
      .style("top", function(d) { return d.x + "px"; })
      .style("width", function(d) { return Math.max(0, d.dy - 1) + "px"; })
      .style("height", function(d) { return Math.max(0, d.dx - 1) + "px"; })
}

function position() {
    this.attr("x", function(d) { return d.y; })
        .attr("y", function(d) { return d.x; })
        .attr("width", function(d) { return Math.max(0, d.dy - 1); })
        .attr("height", function(d) { return Math.max(0, d.dx - 1); });
}

function path_to_url(path) {
    return "http://localhost:8888/"+path+"?collectsize=5%";
}
function path_to_url_html(path) {
    return "http://localhost:8888/"+path+"?view=html";
}
function path_to_url_json(path) {
    return "http://localhost:8888/"+path;
}


</script>
</body>
